% Function providing the attractive component of the gradient descent
% algorithm
% Arguments for att function:
% q = column vector of actual joint angles
% q2 = column vector of final joint angles
% my robot = the robot structure generated by mypuma560 function

function tau = att(q, q2, myrobot)
    
    % Compute current and final origin positions for each link
    for i= 1:6
        q_initial = q(1:i);
        q_final = q2(1:i);
        H_current = forward(q_initial', myrobot);
        H_final = forward(q_final', myrobot);
        o_current{i} = H_current(1:3, 4);
        o_final{i} = H_final(1:3, 4);
        % Get the z vector for Frame i wrt Frame 0
        z{i} = H_current(1:3, 3);
    end
    o_current = [o_current{1} o_current{2} o_current{3} o_current{4} o_current{5} o_current{6}];
    o_final = [o_final{1} o_final{2} o_final{3} o_final{4} o_final{5} o_final{6}];
    z = [z{1} z{2} z{3} z{4} z{5} z{6}];

    % Compute artificial forces of attraction for each DH frame
    zeta = 1; % modify value later for better results
    F = {};
    for i = 1:6
        F{i} = -zeta * (o_current(:,i) - o_final(:,i));
    end
    F = [F{1} F{2} F{3} F{4} F{5} F{6}];
    
    % Compute the velocity Jacobians for each joint
    tau = zeros(6,1);
    for i = 1:6
        Jv = zeros(3,6);
        for j = 1:i
            if j == 1
                % Set base values for vectors z(0) and o(0) wrt Frame 0
                z_v = [0 0 1].';
                o_v = [0 0 0].';
            else
               % Can use values computed above for z(i-1) and o(i-1) wrt Frame 0
               z_v = z(:,j-1);
               o_v = o_current(:,j-1);
            end
            Jv(:,j) = cross(z_v, (o_current(:,i) - o_v));
        end
        % Compute tau
        tau = tau + Jv' * F(:,i);
    end
    
    % Normalize tau as a row vector
    tau = tau';
    if norm(tau) ~= 0
        tau = tau / norm(tau);
    end

end