% Function providing the repulsive component of the gradient descent
% algorithm
% Arguments for rep function:
% q = column vector of actual joint angles
% my robot = the robot structure generated by mypuma560 function
% obs = obstacle data generated by setupobstacle function

function tau = rep(q, myrobot, obs)

    % Define b (as a function of x) for the obstacle
    if strcmp(obs.type,'plane')
        b = @(x) [x(1);x(2);obs.h];     
             % Compute current origin positions for each link
        for i= 1:6
            q_initial = q(1:i);
            H_current = forwardkuka(q_initial', myrobot);
            o_current{i} = H_current(1:3, 4);
            % Get the z vector for Frame i wrt Frame 0
            z{i} = H_current(1:3, 3);
        end
        o_current = [o_current{1} o_current{2} o_current{3} o_current{4} o_current{5} o_current{6}];
        z = [z{1} z{2} z{3} z{4} z{5} z{6}];

        % Compute artificial forces of repulsion for each DH frame
        eta = 1; % modify value later for better results
        F = {};
        for i = 1:6
            if norm(o_current(:,i) - b(o_current(:,i))) <= obs.rho0 % within distance of influence
                F{i} = eta * ( (1/norm(o_current(:,i)-b(o_current(:,i)))) - (1/obs.rho0) ) * ...
                    ( (o_current(:,i) - b(o_current(:,i))) / (norm(o_current(:,i) - b(o_current(:,i))))^3 );
            else % outside distance of influence
                F{i} = [0 0 0]';
            end
        end
        F = [F{1} F{2} F{3} F{4} F{5} F{6}];

        % Compute the velocity Jacobians for each joint
        tau = zeros(6,1);
        for i = 1:6
            Jv = zeros(3,6);
            for j = 1:i
                if j == 1
                    % Set base values for vectors z(0) and o(0) wrt Frame 0
                    z_v = [0 0 1].';
                    o_v = [0 0 0].';
                else
                   % Can use values computed above for z(i-1) and o(i-1) wrt Frame 0
                   z_v = z(:,j-1);
                   o_v = o_current(:,j-1);
                end
                Jv(:,j) = cross(z_v, (o_current(:,i) - o_v));
            end
            % Compute tau
            tau = tau + Jv' * F(:,i);
        end

        % Normalize tau as a row vector
        tau = tau';
        if norm(tau) ~= 0
            tau = tau / norm(tau);
        end
        
    elseif strcmp(obs.type,'cyl')
         
        % Compute current origin positions for each link
        for i= 1:6
            q_initial = q(1:i);
            H_current = forwardkuka(q_initial', myrobot);
            o_current{i} = H_current(1:3, 4);
            % Get the z vector for Frame i wrt Frame 0
            z{i} = H_current(1:3, 3);
        end
        o_current = [o_current{1} o_current{2} o_current{3} o_current{4} o_current{5} o_current{6}];
        z = [z{1} z{2} z{3} z{4} z{5} z{6}];        
       
        % Compute artificial forces of repulsion for each DH frame
        eta = 1; % modify value later for better results
        F = {};
        for i = 1:6
            if o_current(3,i)<obs.h
                b = @(x) [obs.c + obs.R * (x(1:2) - obs.c)/norm(x(1:2) - obs.c) ; x(3)];
            elseif norm(o_current((1:2),i)-obs.c)<obs.R
                b= @(x) [x(1:2);obs.h];
            else
                
                b= @(x) [ obs.c + obs.R * (x(1:2) - obs.c)/norm(x(1:2) - obs.c)     ;obs.h];
            end
            %disp(o_current(:,i))
            %disp( b(o_current(:,i)))
            if norm(o_current(:,i) - b(o_current(:,i))) <= obs.rho0 % within distance of influence
                F{i} = eta * ( (1/norm(o_current(:,i)-b(o_current(:,i)))) - (1/obs.rho0) ) * ...
                    ( (o_current(:,i) - b(o_current(:,i))) / (norm(o_current(:,i) - b(o_current(:,i))))^3 );
            else % outside distance of influence
                F{i} = [0 0 0]';
            end
        end
        F = [F{1} F{2} F{3} F{4} F{5} F{6}];
        %disp(F)
        % Compute the velocity Jacobians for each joint
        tau = zeros(6,1);
        for i = 1:6
            Jv = zeros(3,6);
            for j = 1:i
                if j == 1
                    % Set base values for vectors z(0) and o(0) wrt Frame 0
                    z_v = [0 0 1].';
                    o_v = [0 0 0].';
                else
                   % Can use values computed above for z(i-1) and o(i-1) wrt Frame 0
                   z_v = z(:,j-1);
                   o_v = o_current(:,j-1);
                end
                Jv(:,j) = cross(z_v, (o_current(:,i) - o_v));
            end
            % Compute tau
            tau = tau + Jv' * F(:,i);
        end
        % Normalize tau as a row vector
        tau = tau';
        if norm(tau) ~= 0
            tau = tau / norm(tau);
        end
    end

end
